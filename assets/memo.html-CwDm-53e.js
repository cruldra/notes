import{_ as o,r as a,o as d,c as p,a as i,b as e,d as s,w as r,e as n}from"./app-Bmelea3n.js";const c={},h=n('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>React</code>中的<code>memo</code>是一个高阶组件,<strong>其目的是对组件进行性能优化</strong>.</p><p>当你将一个组件包裹在<code>React.memo</code>中时,<code>React</code>将会对该组件的<code>props</code>进行浅比较,当组件的<code>props</code> 没有发生变化时,它会跳过渲染,从而避免不必要的更新,提高应用的性能.</p></div>',2),m=i("em",null,[e("如果一个组件的父组件重新渲染,那即使这个子组件的"),i("code",null,"props"),e("和"),i("code",null,"state"),e("没有变化,子组件默认也会重新渲染.")],-1),k=i("p",null,[e("而导致父组件重新渲染的原因有很多种,"),i("strong",null,[e("换句话说,如果父组件因为某些原因需要经常重新渲染,但是传递给这个子组件的"),i("code",null,"props"),e(" 又不会变化的情况下,这时就可以考虑使用"),i("code",null,"memo"),e("包裹子组件来避免不必要的渲染")])],-1),g=i("p",null,"看看这两个例子:",-1),B=i("p",null,[e("在上面的例子中,子组件没有用"),i("code",null,"memo"),e("包裹,所以每次父组件重新渲染(由"),i("code",null,"setCount"),e("的调用触发)时,即使子组件的"),i("code",null,"props"),e("值始终是"),i("code",null,"1"),e(" ,它也会重新渲染(时间戳每次都变了).")],-1),u=i("p",null,[e("现在我们再用"),i("code",null,"memo"),e("函数包裹一下子组件:")],-1),y=n(`<p>用<code>memo</code>函数包裹后,现在再点击<code>+</code>或者<code>-</code>按钮,子组件的时间戳始终是第一次渲染出来的,说明子组件没有重新渲染.</p><h2 id="用法" tabindex="-1"><a class="header-anchor" href="#用法"><span>用法</span></a></h2><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> MyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ... 这里是组件的实现 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者使用箭头函数:</p><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> MyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ... 这里是组件的实现 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h2><ol><li><code>React.memo</code>只检查 <code>props</code>的变化.如果组件依赖于<code>state</code>或<code>context</code>,并且这些值发生变化,即便是被React.memo包裹,组件也会重新渲染.</li><li>默认情况下,<code>React.memo</code>使用浅比较.如果需要进行更复杂的比较,可以传递第二个参数作为比较函数.</li><li><code>React.memo</code>并不是防止组件重新渲染的银弹.在某些情况下,使用它可能不会带来性能提升,甚至可能会有性能损失( 比如对于始终会随父组件变化而变化的<code>props</code>,增加了比较操作的开销).因此,只建议在确实需要优化的组件上使用<code>React.memo</code>.</li></ol><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h2><p>在以下几种情况下可以考虑使用<code>React.memo</code>来优化组件渲染性能:</p><ol><li>相对复杂,或者渲染开销(性能消耗)较大的组件.</li><li>父组件频繁更新,但是这些更新并不影响子组件的<code>props</code>.</li><li>长列表中的列表项组件,因为列表项组件的数量可能非常多,所以需要尽量减少不必要的渲染.</li></ol><p>在以下几种情况下不建议使用<code>React.memo</code>:</p><ol><li>组件很简单,渲染开销几乎可以忽略不计.</li><li>组件的<code>props</code>在几乎每次渲染时都会变化.</li><li>组件有大量的<code>props</code>,这会使得<code>浅比较</code>的开销大于组件的渲染开销.</li></ol>`,12);function E(A,v){const l=a("RouteLink"),t=a("SandPack");return d(),p("div",null,[h,i("p",null,[e("在"),s(l,{to:"/Programming/Frontend/React/%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93.html#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91%E7%BB%84%E4%BB%B6%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93"},{default:r(()=>[e("哪些情况下会导致组件重新渲染")]),_:1}),e("中提到-* "),m,e("*")]),k,g,s(t,{theme:"dark",title:"React%20%E7%A4%BA%E4%BE%8B%20",template:"react-ts",files:"eJyVUk1Lw0AQ/StDTgn9iL3GJCD1H9Sb8ZCkWw1Ndksyq4Ul4KGoF0EQPHgRvIogHopYf04/9F+42RhabT10TjPLe8N7b1Zo5t5g0MRsqFlalAxYiiB4Rtp+HAd+2K9DQhJWB/nUQR9JDr2UJeBpKfFD9LRdj3o0ZDRD6PAAHNBFxoM24xRzCwRUgwWUJwFJITfAcUF4FGSlBHlKwXbLsSj7pOXOnm8Wk9F0Ml7cj8KCPTv/sJZ7bVNi/mF8Pj59XV7P717mb6/zh9vp+4Wg5Az2pXTdaB4TPIgS2a3usE3Z5B4lQ+W+S3o+jxH0VaGlw0Mlpg4ZQaXkSPqtgtF3jF/QSq1Cy2jWCa0fQhVCNzr942pxNd6Qg+rWQgg4IqPAaDuOwr4jSvmVUl2RoAYtI3drtlmit+Y3FL+xiV9cv/LsLG9VZFuGXNiTv0UGreXfMiHhOQ==",options:"eJyrrgUAAXUA+Q==",customSetup:"eJyrVkpJLUjNS0nNS85MLVayqq6tBQBIPQdW"}),B,u,s(t,{theme:"dark",title:"React%20%E7%A4%BA%E4%BE%8B2%20",template:"react-ts",files:"eJyVUstKw0AU/ZVLVgl9xG5jEpD6B3XnuEjSqYYmMyWZ0cIw4KKoG0EQXLgR3IogLopYP6cP/QsnE0ODrQvv6t7hnMs5Z64w7L3RqM3yseEYcTqiGQPBc9wNkiQMomETUpzSJqinHgsYljDIaArIyHAQMWTsIoJIREnOoMdD8DTcNEXOwy7lhEkHBFSDA4SnIc5AWuD5IBABVRlmPCPg+uVYlHvS8RfPN6vZZD6bru4nUcFenH84672urTB/MD4fn74ur5d3L8u31+XD7fz9QhB8BvtKv2m1jzE7iFPV1Xe4tmqkhQge6wz6eBDwhIFZV1r6PNRqmpBjpqUcKddVPOaOWlGDVnI1WgW0Sej8EKoU+vHpL1urq+mWIHS3kULIGaMEKOkmcTT0RCm/UmpqEjSgY0m/4dol+t/8lua3tvGLG6g8e+vPKsItUy7sqZuRiBjyG1jh4zg=",options:"eJyrrgUAAXUA+Q==",customSetup:"eJyrVkpJLUjNS0nNS85MLVayqq6tBQBIPQdW"}),y])}const F=o(c,[["render",E],["__file","memo.html.vue"]]),R=JSON.parse('{"path":"/Programming/Frontend/React/memo.html","title":"memo","lang":"zh-CN","frontmatter":{"title":"memo","comment":false,"editLink":false,"prev":false,"next":false,"description":"简介 提示 React中的memo是一个高阶组件,其目的是对组件进行性能优化. 当你将一个组件包裹在React.memo中时,React将会对该组件的props进行浅比较,当组件的props 没有发生变化时,它会跳过渲染,从而避免不必要的更新,提高应用的性能. 在中提到-* 如果一个组件的父组件重新渲染,那即使这个子组件的props和state没有变化...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/Programming/Frontend/React/memo.html"}],["meta",{"property":"og:site_name","content":"一星的臭弟弟"}],["meta",{"property":"og:title","content":"memo"}],["meta",{"property":"og:description","content":"简介 提示 React中的memo是一个高阶组件,其目的是对组件进行性能优化. 当你将一个组件包裹在React.memo中时,React将会对该组件的props进行浅比较,当组件的props 没有发生变化时,它会跳过渲染,从而避免不必要的更新,提高应用的性能. 在中提到-* 如果一个组件的父组件重新渲染,那即使这个子组件的props和state没有变化..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T23:01:39.000Z"}],["meta",{"property":"article:author","content":"Cruldra"}],["meta",{"property":"article:modified_time","content":"2024-07-03T23:01:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"memo\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-03T23:01:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cruldra\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"用法","slug":"用法","link":"#用法","children":[]},{"level":2,"title":"特点","slug":"特点","link":"#特点","children":[]},{"level":2,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}],"git":{"createdTime":1720047699000,"updatedTime":1720047699000,"contributors":[{"name":"cruldra","email":"cruldra@gmail.com","commits":1}]},"readingTime":{"minutes":3.33,"words":1000},"filePathRelative":"Programming/Frontend/React/memo.md","localizedDate":"2024年7月3日","autoDesc":true}');export{F as comp,R as data};
