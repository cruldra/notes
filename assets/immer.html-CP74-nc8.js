import{_ as n,r,o as l,c as d,d as a,a as e,b as t,w as c,e as o}from"./app-Bmelea3n.js";const h={},p=e("h2",{id:"简介",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#简介"},[e("span",null,"简介")])],-1),m=e("p",null,[t("在"),e("code",null,"JavaScript"),t(" 中,对象和数组是引用类型,这意味着"),e("mark",null,"如果你直接修改了一个对象或数组,那么所有引用了这个对象或数组的地方都会受到影响"),t(".下面的例子证明了这一点:")],-1),k=o('<p>从上面的例子中可以看到,尽管我们试图基于<code>baseState</code>来创建一个<code>newState</code></p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> newState</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> baseState</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>但是对<code>newState</code>的更改仍然会反映到<code>baseState</code>上.</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">baseState</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> newState</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这在复杂的应用中可能会导致不可预测的结果,尤其是在状态管理时</p><p><a href="https://www.npmjs.com/package/immer" target="_blank" rel="noopener noreferrer">immer</a>提供了一种简单的方法来处理不可变数据更新,你可以用一种看似<code>可变</code> 的方式编写代码,immer在内部会处理这些更新,确保不会修改原始状态,而是创建一个新的状态副本来反映这些更新.</p>',6),g=e("p",null,[t("现在我们使用"),e("code",null,"immer"),t("来重写上面的例子:")],-1),u=o('<h2 id="为什么要使用不可变数据" tabindex="-1"><a class="header-anchor" href="#为什么要使用不可变数据"><span>为什么要使用<code>不可变数据</code></span></a></h2><p><a href="https://poe.com/s/fItBeZ48i4KrnanlpJTF" target="_blank" rel="noopener noreferrer">这里</a>介绍了一个不使用<code>不可变数据</code>可能会出现的糟糕的情况</p><h2 id="和lodash的deepclone的区别" tabindex="-1"><a class="header-anchor" href="#和lodash的deepclone的区别"><span>和<code>lodash</code>的<code>deepClone</code>的区别</span></a></h2><p><code>immer</code>的<code>produce</code>函数与简单地创建一个深度克隆对象有本质的区别.</p><p>虽然结果可能看起来类似即你最终得到了一个修改后的状态,而原始状态保持不变.但是<code>immer</code>的方法在性能和内存使用方面通常更优.</p><p>下面是<code>immer</code>和<code>deepClone</code>之间的一些关键区别:</p><ul><li><strong>不变性保证</strong></li></ul><table><thead><tr><th>deepClone</th><th>immer</th></tr></thead><tbody><tr><td>创建对象的一个完全独立副本,包括所有嵌套的对象.这意味着无论原始对象的结构有多复杂,都会创建一个全新的结构,这可能涉及大量的处理和内存分配</td><td>只在需要时创建副本.如果你没有修改某个对象,<code>immer</code>不会复制它.这种方法称为结构共享,它可以显著减少不必要的复制,提高效率</td></tr></tbody></table><ul><li><strong>性能</strong></li></ul><table><thead><tr><th>deepClone</th><th>immer</th></tr></thead><tbody><tr><td>通常更消耗资源,因为无论是否需要,它都会复制整个对象树</td><td>通常提供更好的性能,因为它只在必要时创建新对象.如果你修改了对象的某个部分,只有那部分和它的父路径会被复制和更新.</td></tr></tbody></table><ul><li><strong>内部工作机制</strong></li></ul><table><thead><tr><th>deepClone</th><th>immer</th></tr></thead><tbody><tr><td>通过递归复制所有属性来实现</td><td>使用<code>ES6</code>的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy</a>对象来监视状态的修改,只有当属性被修改时,才会复制原始对象的对应部分.</td></tr></tbody></table>',12);function b(y,f){const i=r("SandPack"),s=r("RouteLink");return l(),d("div",null,[p,m,a(i,{theme:"dark",title:"React%20%E7%A4%BA%E4%BE%8B%20",template:"react-ts",files:"eJxtUjtOw0AQvcpomziSlfQmNuLXIRrosin8mQgLe9esZyGW5StQ0VHTUtFQcRkUrsH6Fycm09i78+a9NzNbsvlZls0o3zCHxWkmFUGZYipt0Dnekk9YwVrJFCYK/ZAmJ1xwEUqREwR+hwAXllyAiZJkJB3g7Bp9JYCKDPNQxRlxZkMkBTpASmNlj+B3qoA4TVENuLWf5FhxsTKKrZ7A515uJ80FbhrTEa59nRBYU3A9KFv+tm65Q1893nQcNuRI5//vV4a8b3wRSJmgLzxruk+ns8gkL2OFISWFwR9I1tEbnWU6v7f2EnX0Ldc5CIoR3eGchsqqs1DHcefW3jpcd+ehqzODrD8KSZu9LKL4yRsIR8fmKtBEUoAUF0kcPrjloc3K+3373L68/3x/bF+/FvMWPeI4bgic8sg+4NSMpGmZQT2dZvucdbYbR/PBZftvHobJs+oPR3fq/g==",options:"eJyrrgUAAXUA+Q==",customSetup:"eJyrVkpJLUjNS0nNS85MLVayqlbKzM1NLVKyUoozNFCqrQUAvlQK8Q=="}),k,e("p",null,[t("这样做的好处是代码更易读、易写,同时依然保持了数据的"),a(s,{to:"/Programming/Terminology/%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7(Immutability).html"},{default:c(()=>[t("不可变性(Immutability)")]),_:1}),t(".")]),g,a(i,{theme:"dark",title:"React%20%E7%A4%BA%E4%BE%8B%20",template:"react-ts",files:"eJx9UjtOw0AQvcrIDYkUJX2IgwiiQEI00GVTOPZEWNi7Zj2GRJY7JKCHBjgABRLUoIjL4OQarP+xiZjGno/fvPfGodbb97wu+XOtr9muJyRB6KIrOhD4eEoGYQQzKVzYkWiYtLPLeDHmSWEFZtm3XRdl0mfcFNwnmBo5AugwZhxUhCQs0QemHaMhOdDCQ9+UtkdM64AlOPaBZIBRpzF+JheQ4ldzM8PxMWJ8ojY6SMDxulhWLmYc5ylXC2dG4BC02qAPIczQM5bjcvrw8iTH6ICPNPpbnyjwwpbBVAgHDT5sbejU9ZJHe3NJ4FmqNFocJRoUSI1HEhvsc1srWKVYGjPK+7XPkqiaXS/wz1ulaUkG00V9edPAtrKvQKol2x34X6w6R/KQSIG67sCyr4YVYCNNS9OASHAQ/MCxzQs9rFGNhj/L7/XDa3r49dNNbkx8u1w9fsR3z/HXZ3z/vnp5G/QynAb6dqrQD7dcHPaUYcmvxzRIvEvNYVouKOXaq/hn78os1deiXx6/HnA=",options:"eJyrrgUAAXUA+Q==",customSetup:"eJyrVkpJLUjNS0nNS85MLVayqlbKzM1NLVKyUoozNFCqrQUAvlQK8Q=="}),u])}const S=n(h,[["render",b],["__file","immer.html.vue"]]),A=JSON.parse('{"path":"/Programming/Frontend/ReactLibs/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/immer.html","title":"immer","lang":"zh-CN","frontmatter":{"title":"immer","comment":false,"editLink":false,"prev":false,"next":false,"description":"简介 在JavaScript 中,对象和数组是引用类型,这意味着如果你直接修改了一个对象或数组,那么所有引用了这个对象或数组的地方都会受到影响.下面的例子证明了这一点: 从上面的例子中可以看到,尽管我们试图基于baseState来创建一个newState 但是对newState的更改仍然会反映到baseState上. 这在复杂的应用中可能会导致不可预测...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/Programming/Frontend/ReactLibs/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/immer.html"}],["meta",{"property":"og:site_name","content":"一星的臭弟弟"}],["meta",{"property":"og:title","content":"immer"}],["meta",{"property":"og:description","content":"简介 在JavaScript 中,对象和数组是引用类型,这意味着如果你直接修改了一个对象或数组,那么所有引用了这个对象或数组的地方都会受到影响.下面的例子证明了这一点: 从上面的例子中可以看到,尽管我们试图基于baseState来创建一个newState 但是对newState的更改仍然会反映到baseState上. 这在复杂的应用中可能会导致不可预测..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T23:01:39.000Z"}],["meta",{"property":"article:author","content":"Cruldra"}],["meta",{"property":"article:modified_time","content":"2024-07-03T23:01:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"immer\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-03T23:01:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cruldra\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"为什么要使用不可变数据","slug":"为什么要使用不可变数据","link":"#为什么要使用不可变数据","children":[]},{"level":2,"title":"和lodash的deepClone的区别","slug":"和lodash的deepclone的区别","link":"#和lodash的deepclone的区别","children":[]}],"git":{"createdTime":1720047699000,"updatedTime":1720047699000,"contributors":[{"name":"cruldra","email":"cruldra@gmail.com","commits":1}]},"readingTime":{"minutes":2.91,"words":872},"filePathRelative":"Programming/Frontend/ReactLibs/数据管理/immer.md","localizedDate":"2024年7月3日","autoDesc":true}');export{S as comp,A as data};
