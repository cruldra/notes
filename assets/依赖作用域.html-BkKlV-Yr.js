import{i as a,_ as n,r as i,o as l,c as s,d as F,e as t}from"./app-Bmelea3n.js";const r=a({__name:"依赖作用域.html",setup(c,{expose:d}){d();const e={images1:[{src:"https://cdn.jsdelivr.net/gh/hhypygy/images@master/20231227/1.1cqg54mxo5eo.svg",alt:""}],images2:[{src:"https://cdn.jsdelivr.net/gh/hhypygy/images@master/20231227/2.5tzampruofc0.svg",alt:""}]};return Object.defineProperty(e,"__isScriptSetup",{enumerable:!1,value:!0}),e}}),D=t('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>现代软件通常包括大量第三方依赖,它们彼此协作使我们能够开发复杂的大型应用</p><p>随着项目越来越大,依赖管理变得很复杂,所以我们需要引入像<code>Gradle</code>和<code>Maven</code>这样的构建工具可以帮助我们管理这些依赖,使我们把有限的时间和精力更多的放在业务逻辑上</p><p>要理解<code>作用域</code>这个概念,我们需要首先了解一下应用程序的生命周期,一个应用程序的生命周期通常包括以下几个阶段:</p><table><thead><tr><th>生命周期</th><th>描述</th><th>涉及到的组件</th></tr></thead><tbody><tr><td>编译</td><td>对源代码进行编译或者解释</td><td>编译器或者解释器</td></tr><tr><td>测试</td><td>对编译后的代码进行测试</td><td>测试框架</td></tr><tr><td>打包</td><td>将编译后的代码打包成可执行的文件</td><td>打包工具</td></tr><tr><td>部署</td><td>将打包后的文件部署到服务器上</td><td>部署工具</td></tr><tr><td>运行</td><td>运行部署后的应用程序</td><td>运行时环境</td></tr></tbody></table><p>下面这张表格列出了<code>Gradle</code>中的主要几种<code>依赖作用域</code>以及<code>Maven</code>中对应的作用域:</p><table><thead><tr><th>作用域</th><th>描述</th><th>对应的Maven作用域</th></tr></thead><tbody><tr><td><code>implementation</code></td><td>仅在当前模块的编译时和运行时可用</td><td><code>compile</code></td></tr><tr><td><code>api</code></td><td>编译时和运行时都可用,同时会将依赖传递给依赖当前模块的其它模块</td><td><code>compile</code></td></tr><tr><td><code>compileOnly</code></td><td>依赖仅在编译时有效,不会传递给运行时(不会打包)</td><td><code>provided</code></td></tr><tr><td><code>runtimeOnly</code></td><td>依赖仅在运行时有效,你在编译期间(就是源码阶段)是访问不到这个依赖中的类的,比如<code>jdbc</code>驱动</td><td><code>runtime</code></td></tr><tr><td><code>testImplementation</code></td><td>仅在测试时可用</td><td><code>test</code></td></tr><tr><td><code>testCompileOnly</code></td><td>仅在测试时可用,不会传递给运行时</td><td></td></tr><tr><td><code>testRuntimeOnly</code></td><td>仅在测试时可用,不会传递给编译时</td><td></td></tr></tbody></table><p>如果对软件生命周期没有深刻理解的话,上面这张表看起来可能还是有点晦涩难懂,下面从实际应用的角度来解释下几个主要作用域的用法</p><h2 id="implementation" tabindex="-1"><a class="header-anchor" href="#implementation"><span>implementation</span></a></h2><p>先看看这张图</p>',10),p=t('<p>这里有三个项目<code>A</code>,<code>B</code>,<code>C</code>,项目A中有一个<code>StrUtil</code>,项目<code>B</code>通过<code>implementation</code>引用<code>A</code>,项目<code>C</code>再通过<code>implementation</code>引用<code>B</code></p><p>这种情况下:</p><ol><li>你在为<code>B</code>编写代码时是访问<code>A</code>中的<code>StrUtil</code>的,但为项目<code>C</code>编写代码时是访问不到的,因为<code>B</code>没有把对<code>A</code>的<code>编译期依赖</code> 传递给<code>C</code></li><li>打包的时候,如果你在<code>B</code>中引用过<code>A</code>,那么<code>A</code>会被打包到<code>B</code>项目最终的<code>jar</code>包中,但是如果你在<code>B</code>中没有引用过<code>A</code>,那么<code>A</code> 不会被打包到<code>B</code>项目最终的<code>jar</code>包中</li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>implementation</code>的这一特性可以用来避免暴露过多的依赖细节、减少编译时间及避免依赖冲突,从而实现<strong>按需打包</strong></p></div><h2 id="api" tabindex="-1"><a class="header-anchor" href="#api"><span>api</span></a></h2>',5),B=t(`<p>现在来看看当项目<code>B</code>使用<code>api</code>引用<code>A</code>时,会发生什么:</p><ol><li>这时候项目<code>C</code>就可以访问<code>A</code>中的<code>StrUtil</code>了,因为<code>B</code>现在把对<code>A</code>的<code>编译期依赖</code>传递给了<code>C</code></li><li>在对<code>C</code>打包的时候,无论你在<code>B</code>中是否引用过<code>A</code>,都会把<code>A</code>打包到<code>B</code>项目最终的<code>jar</code>包中</li></ol><h2 id="compileonly" tabindex="-1"><a class="header-anchor" href="#compileonly"><span>compileOnly</span></a></h2><p>这个用于需要在编译时使用,但在运行时由具体的<code>运行时环境</code>来决定具体依赖哪些依赖的情况</p><p>一个典型的例子是:</p><p>假设你现在正在针对各种不同平台的<code>短消息服务(sms)</code>做一个统一的封装,但最终使用的是<code>阿里云</code>的还是<code>华为云</code> 由最终的运行时环境来决定,这时候你就可以使用<code>compileOnly</code>来引用<code>阿里云</code>和<code>华为云</code>的<code>sdk</code> ,让它们参与当前这个项目的编译,但是当你使用这个封装的时候,你还需要根据具体的业务需要使用<code>implementation</code>引用<code>阿里云</code> 或者<code>华为云</code>的<code>sdk</code></p><div class="language-gradle line-numbers-mode" data-highlighter="shiki" data-ext="gradle" data-title="gradle" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>dependencies {</span></span>
<span class="line"><span>    compileOnly(&quot;com.aliyun.oss:aliyun-sdk-oss&quot;)</span></span>
<span class="line"><span>    compileOnly(&quot;com.aliyun.oss:huawei-sdk-oss&quot;)</span></span>
<span class="line"><span>    compileOnly(&quot;com.aliyun.oss:tx-sdk-oss&quot;)</span></span>
<span class="line"><span>    compileOnly(&quot;com.aliyun.oss:google-sdk-oss&quot;)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://docs.gradle.org/current/userguide/declaring_dependencies.html" target="_blank" rel="noopener noreferrer">Declaring dependencies</a></li></ul>`,9);function C(c,d,E,u,e,m){const o=i("ImageRenderer");return l(),s("div",null,[D,F(o,{value:u.images1}),p,F(o,{value:u.images2}),B])}const h=n(r,[["render",C],["__file","依赖作用域.html.vue"]]),g=JSON.parse('{"path":"/Tools/Gradle/%E4%BE%9D%E8%B5%96%E4%BD%9C%E7%94%A8%E5%9F%9F.html","title":"依赖作用域","lang":"zh-CN","frontmatter":{"title":"依赖作用域","comment":false,"editLink":false,"prev":false,"next":false,"description":"简介 现代软件通常包括大量第三方依赖,它们彼此协作使我们能够开发复杂的大型应用 随着项目越来越大,依赖管理变得很复杂,所以我们需要引入像Gradle和Maven这样的构建工具可以帮助我们管理这些依赖,使我们把有限的时间和精力更多的放在业务逻辑上 要理解作用域这个概念,我们需要首先了解一下应用程序的生命周期,一个应用程序的生命周期通常包括以下几个阶段: ...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/Tools/Gradle/%E4%BE%9D%E8%B5%96%E4%BD%9C%E7%94%A8%E5%9F%9F.html"}],["meta",{"property":"og:site_name","content":"一星的臭弟弟"}],["meta",{"property":"og:title","content":"依赖作用域"}],["meta",{"property":"og:description","content":"简介 现代软件通常包括大量第三方依赖,它们彼此协作使我们能够开发复杂的大型应用 随着项目越来越大,依赖管理变得很复杂,所以我们需要引入像Gradle和Maven这样的构建工具可以帮助我们管理这些依赖,使我们把有限的时间和精力更多的放在业务逻辑上 要理解作用域这个概念,我们需要首先了解一下应用程序的生命周期,一个应用程序的生命周期通常包括以下几个阶段: ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T23:01:39.000Z"}],["meta",{"property":"article:author","content":"Cruldra"}],["meta",{"property":"article:modified_time","content":"2024-07-03T23:01:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"依赖作用域\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-03T23:01:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cruldra\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"implementation","slug":"implementation","link":"#implementation","children":[]},{"level":2,"title":"api","slug":"api","link":"#api","children":[]},{"level":2,"title":"compileOnly","slug":"compileonly","link":"#compileonly","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1720047699000,"updatedTime":1720047699000,"contributors":[{"name":"cruldra","email":"cruldra@gmail.com","commits":1}]},"readingTime":{"minutes":3.6,"words":1079},"filePathRelative":"Tools/Gradle/依赖作用域.md","localizedDate":"2024年7月3日","autoDesc":true}');export{h as comp,g as data};
